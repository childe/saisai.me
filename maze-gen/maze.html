<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>迷宫生成器</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        
        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 10px;
            box-sizing: border-box;
        }
        
        h1 {
            color: #333;
            margin-bottom: 15px;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            text-align: center;
        }
        
        .size-controls {
            margin: 15px 0;
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
        }
        
        .size-btn {
            padding: 10px 16px;
            font-size: clamp(12px, 3vw, 14px);
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 60px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .size-btn:hover {
            background-color: #45a049;
            transform: translateY(-1px);
        }
        
        .size-btn.active {
            background-color: #2196F3;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        #maze {
            padding: 10px;
            display: grid;
            gap: 0;
            border: 1px solid #ccc;
            background-color: #fff;
            margin: 15px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
            max-width: 95vw;
            max-height: 70vh;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            position: relative;
        }
        
        .swipe-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #2196F3;
            font-size: 24px;
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .cell {
            width: 8px;
            height: 8px;
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        .wall {
            background-color: #fff;
        }
        
        .path {
            background-color: #fff;
        }
        
        .solution {
            background-color: #ff0000 !important;
            opacity: 0.8;
        }
        
        .entrance {
            background-color: #4CAF50;
        }
        
        .exit {
            background-color: #f44336;
        }
        
        .player {
            background-color: #000 !important;
            border-radius: 2px;
            position: relative;
            z-index: 10;
        }
        
        .player::after {
            content: '●';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 60%;
            line-height: 1;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 15px;
            width: 100%;
        }
        
        button {
            margin: 0;
            padding: 12px 20px;
            font-size: clamp(14px, 3.5vw, 16px);
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-width: 120px;
            flex: 1;
            max-width: 200px;
        }
        
        button:hover {
            background-color: #1976D2;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        /* 移动端适配 */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .container {
                padding: 0 5px;
            }
            
            h1 {
                margin-bottom: 10px;
            }
            
            .size-controls {
                margin: 10px 0;
                gap: 6px;
            }
            
            .size-btn {
                padding: 8px 12px;
                min-width: 50px;
                font-size: 12px;
            }
            
            #maze {
                margin: 10px 0;
                max-width: 98vw;
                max-height: 60vh;
            }
            
            .action-buttons {
                margin-top: 10px;
                gap: 8px;
            }
            
            button {
                padding: 10px 16px;
                min-width: 100px;
                font-size: 14px;
            }
        }
        
        @media (max-width: 480px) {
            .size-btn {
                padding: 6px 10px;
                min-width: 45px;
                font-size: 11px;
            }
            
            button {
                padding: 8px 12px;
                min-width: 80px;
                font-size: 13px;
            }
            
            #maze {
                max-height: 50vh;
            }
        }
        
    </style>
</head>
<body>
    <div class="container">
        <h1>迷宫生成器</h1>
        
        <div class="size-controls">
            <button class="size-btn" onclick="setMazeSize(10)" id="size-10">10×10</button>
            <button class="size-btn" onclick="setMazeSize(20)" id="size-20">20×20</button>
            <button class="size-btn" onclick="setMazeSize(30)" id="size-30">30×30</button>
            <button class="size-btn" onclick="setMazeSize(40)" id="size-40">40×40</button>
            <button class="size-btn active" onclick="setMazeSize(50)" id="size-50">50×50</button>
        </div>
        
        <div id="maze">
            <div class="swipe-indicator" id="swipeIndicator"></div>
        </div>
        
        <div class="action-buttons">
            <button onclick="generateMaze()">重新生成</button>
            <button onclick="showPath()">显示道路</button>
            <button onclick="hidePath()">隐藏道路</button>
        </div>
        
        <div style="margin-top: 15px; text-align: center; color: #666; font-size: clamp(12px, 2.5vw, 14px);">
            <p>使用键盘方向键或在迷宫上滑动手势控制小人移动</p>
        </div>
    </div>

    <script>
        class MazeGenerator {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.maze = [];
                this.connections = []; // Store connection info for each cell
                this.originalMainPath = []; // Store the original main path
            }

            generate() {
                // Initialize maze with all walls (1 = wall, 0 = path)
                this.maze = Array(this.height).fill().map(() => Array(this.width).fill(1));
                
                // Set entrance and exit as paths
                this.maze[0][0] = 0; // Entrance
                this.maze[this.height - 1][this.width - 1] = 0; // Exit
                
                // Set entrance adjacent cells as paths
                if (this.width > 1) this.maze[0][1] = 0; // Right of entrance
                if (this.height > 1) this.maze[1][0] = 0; // Below entrance
                
                // Set exit adjacent cells as paths  
                if (this.width > 1) this.maze[this.height - 1][this.width - 2] = 0; // Left of exit
                if (this.height > 1) this.maze[this.height - 2][this.width - 1] = 0; // Above exit
                
                // Initialize connections array - each cell has connections in 4 directions
                // connections[row][col] = {up: false, down: false, left: false, right: false}
                this.connections = Array(this.height).fill().map(() => 
                    Array(this.width).fill().map(() => ({up: false, down: false, left: false, right: false}))
                );
                
                // Step 1: Create entrance and exit - they are walls with openings to outside
                // Entrance at top-left corner - opening on top and left edges
                this.connections[0][0].up = true; // Opening to outside (top edge)
                this.connections[0][0].left = true; // Opening to outside (left edge)
                
                // Exit at bottom-right corner - opening on bottom and right edges  
                this.connections[this.height - 1][this.width - 1].down = true; // Opening to outside (bottom edge)
                this.connections[this.height - 1][this.width - 1].right = true; // Opening to outside (right edge)
                
                // Step 2: Generate a random path from entrance to exit
                this.createRandomMainPath();
                
                // Step 3: For non-path cells, randomly open 1-2 directions
                this.randomlyOpenWallConnections();
                
                // Step 4: Eliminate redundant paths, keeping only the main path
                // TEMPORARILY DISABLED FOR DEBUGGING
                // this.eliminateRedundantPaths();
                
                return {maze: this.maze, connections: this.connections};
            }
            
            createRandomMainPath() {
                // Generate path data and create connections immediately
                const pathSteps = this.generatePathSteps();
                this.createConnections(pathSteps);
            }
            
            generatePathSteps() {
                // Start from a cell adjacent to entrance to a cell adjacent to exit
                let currentRow = 1;
                let currentCol = 1;
                const targetRow = this.height - 2;
                const targetCol = this.width - 2;
                
                // Track visited cells to prevent going back
                const visited = Array(this.height).fill().map(() => Array(this.width).fill(false));
                const pathSteps = [];
                
                // Clear starting point
                visited[currentRow][currentCol] = true;
                pathSteps.push([currentRow, currentCol]);
                
                // Pure random walk to exit without revisiting cells
                while (currentRow !== targetRow || currentCol !== targetCol) {
                    // Get all possible valid directions (within bounds and not visited)
                    const validDirections = [];
                    const allDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // up, down, left, right
                    
                    for (const [dr, dc] of allDirections) {
                        const newRow = currentRow + dr;
                        const newCol = currentCol + dc;
                        
                        // Check if within bounds and not previously visited
                        if (newRow > 0 && newRow < this.height - 1 && 
                            newCol > 0 && newCol < this.width - 1 && 
                            !visited[newRow][newCol]) {
                            validDirections.push([dr, dc]);
                        }
                    }
                    
                    // If we have valid directions, choose randomly
                    if (validDirections.length > 0) {
                        const [dr, dc] = validDirections[Math.floor(Math.random() * validDirections.length)];
                        currentRow += dr;
                        currentCol += dc;
                        visited[currentRow][currentCol] = true;
                        pathSteps.push([currentRow, currentCol]);
                    } else {
                        // If no valid unvisited directions, we're stuck
                        // This could happen with pure random walk - need backtracking or restart
                        console.log("Stuck at", currentRow, currentCol, "- restarting path generation");
                        
                        // Restart the path generation
                        currentRow = 1;
                        currentCol = 1;
                        visited.forEach(row => row.fill(false));
                        pathSteps.length = 0; // Clear path steps
                        
                        visited[currentRow][currentCol] = true;
                        pathSteps.push([currentRow, currentCol]);
                    }
                }
                
                return pathSteps;
            }
            
            createConnections(pathSteps) {
                // Store the original main path including entrance and exit
                this.originalMainPath = [[0, 0], ...pathSteps, [this.height - 1, this.width - 1]];
                
                // Set all path cells to be paths in the maze
                for (const [row, col] of pathSteps) {
                    this.maze[row][col] = 0;
                }
                
                // Create connections between adjacent cells in the path
                for (let stepIndex = 0; stepIndex < pathSteps.length; stepIndex++) {
                    const [row, col] = pathSteps[stepIndex];
                    
                    // Set up connections for this step
                    if (stepIndex > 0) {
                        const [prevRow, prevCol] = pathSteps[stepIndex - 1];
                        
                        // Connect current cell to previous cell
                        if (prevRow === row - 1) { // Previous is above
                            this.connections[row][col].up = true;
                            this.connections[prevRow][prevCol].down = true;
                        } else if (prevRow === row + 1) { // Previous is below
                            this.connections[row][col].down = true;
                            this.connections[prevRow][prevCol].up = true;
                        } else if (prevCol === col - 1) { // Previous is left
                            this.connections[row][col].left = true;
                            this.connections[prevRow][prevCol].right = true;
                        } else if (prevCol === col + 1) { // Previous is right
                            this.connections[row][col].right = true;
                            this.connections[prevRow][prevCol].left = true;
                        }
                    }
                    
                    // Connect to entrance - if this is (1,1), connect to entrance at (0,0)
                    if (row === 1 && col === 1) {
                        // Direct connection from entrance (0,0) to (1,1)
                        // Method 1: Connect via (0,1)
                        this.connections[row][col].up = true; // (1,1) -> (0,1)
                        this.connections[0][1].down = true; // (0,1) -> (1,1)
                        this.connections[0][1].left = true; // (0,1) -> (0,0)
                        this.connections[0][0].right = true; // (0,0) -> (0,1)
                        
                        // Method 2: Connect via (1,0)
                        this.connections[row][col].left = true; // (1,1) -> (1,0)
                        this.connections[1][0].right = true; // (1,0) -> (1,1)
                        this.connections[1][0].up = true; // (1,0) -> (0,0)
                        this.connections[0][0].down = true; // (0,0) -> (1,0)
                    }
                    
                    // Connect to exit - if this is (height-2, width-2), connect to exit at (height-1, width-1)
                    if (row === this.height - 2 && col === this.width - 2) {
                        // Direct connection from (height-2, width-2) to exit (height-1, width-1)
                        // Method 1: Connect via (height-1, width-2)
                        this.connections[row][col].down = true; // (h-2,w-2) -> (h-1,w-2)
                        this.connections[this.height - 1][col].up = true; // (h-1,w-2) -> (h-2,w-2)
                        this.connections[this.height - 1][col].right = true; // (h-1,w-2) -> (h-1,w-1)
                        this.connections[this.height - 1][this.width - 1].left = true; // (h-1,w-1) -> (h-1,w-2)
                        
                        // Method 2: Connect via (height-2, width-1)
                        this.connections[row][col].right = true; // (h-2,w-2) -> (h-2,w-1)
                        this.connections[row][this.width - 1].left = true; // (h-2,w-1) -> (h-2,w-2)
                        this.connections[row][this.width - 1].down = true; // (h-2,w-1) -> (h-1,w-1)
                        this.connections[this.height - 1][this.width - 1].up = true; // (h-1,w-1) -> (h-2,w-1)
                    }
                }
                
                console.log("Path generation complete! Total steps:", pathSteps.length);
            }
            
            randomlyOpenWallConnections() {
                // For each internal cell that is a wall, randomly open 1-2 directions
                for (let row = 1; row < this.height - 1; row++) {
                    for (let col = 1; col < this.width - 1; col++) {
                        // Skip cells that are already part of main path
                        if (this.maze[row][col] === 0) {
                            continue;
                        }
                        
                        // This is a wall cell, randomly open 1 or 2 directions
                        const directions = ['up', 'down', 'left', 'right'];
                        
                        // Randomly choose to open 1 or 2 directions (70% chance for 1, 30% chance for 2)
                        const numDirections = Math.random() < 0.7 ? 1 : 2;
                        
                        // Shuffle directions and pick the first numDirections
                        const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);
                        const selectedDirections = shuffledDirections.slice(0, numDirections);
                        
                        // Open the selected directions
                        for (const direction of selectedDirections) {
                            this.connections[row][col][direction] = true;
                            
                            // Also open the corresponding direction in the adjacent cell if it exists
                            let adjRow = row;
                            let adjCol = col;
                            let adjDirection = '';
                            
                            if (direction === 'up') {
                                adjRow = row - 1;
                                adjDirection = 'down';
                            } else if (direction === 'down') {
                                adjRow = row + 1;
                                adjDirection = 'up';
                            } else if (direction === 'left') {
                                adjCol = col - 1;
                                adjDirection = 'right';
                            } else if (direction === 'right') {
                                adjCol = col + 1;
                                adjDirection = 'left';
                            }
                            
                            // Check bounds and open adjacent cell's corresponding direction
                            if (adjRow >= 0 && adjRow < this.height && 
                                adjCol >= 0 && adjCol < this.width) {
                                this.connections[adjRow][adjCol][adjDirection] = true;
                            }
                        }
                    }
                }
            }
            
            randomlyOpenDirections() {
                // For each internal cell, randomly decide whether to make it a path
                for (let row = 1; row < this.height - 1; row++) {
                    for (let col = 1; col < this.width - 1; col++) {
                        // Skip cells that are already part of main path
                        if (this.maze[row][col] === 0) {
                            continue;
                        }
                        
                        // Random chance to make this cell a path (40% chance)
                        if (Math.random() < 0.4) {
                            this.maze[row][col] = 0;
                        }
                    }
                }
            }
            
            // Find all paths from entrance to exit and seal redundant ones
            eliminateRedundantPaths() {
                // Use a much simpler approach: check if multiple paths exist and block strategically
                const mainPath = this.findMainPath();
                if (!mainPath || mainPath.length === 0) {
                    console.log("No main path found");
                    return;
                }
                
                console.log("Main path found with length:", mainPath.length);
                const mainPathCells = new Set(mainPath.map(([r, c]) => `${r},${c}`));
                
                // Simple strategy: block cells that create shortcuts around the main path
                let blockedCells = this.blockShortcutCells(mainPathCells);
                
                console.log(`Simple blocking completed - blocked ${blockedCells} cells`);
            }
            
            // Find the main path from entrance to exit using BFS (shortest path)
            findMainPath() {
                const height = this.height;
                const width = this.width;
                const start = [0, 0]; // Entrance
                const end = [height - 1, width - 1]; // Exit
                
                // BFS to find shortest path
                const queue = [start];
                const visited = Array(height).fill().map(() => Array(width).fill(false));
                const parent = Array(height).fill().map(() => Array(width).fill(null));
                
                visited[start[0]][start[1]] = true;
                const directions = [
                    [-1, 0, 'up', 'down'],
                    [1, 0, 'down', 'up'],
                    [0, -1, 'left', 'right'],
                    [0, 1, 'right', 'left']
                ];
                
                while (queue.length > 0) {
                    const [currentRow, currentCol] = queue.shift();
                    
                    if (currentRow === end[0] && currentCol === end[1]) {
                        break;
                    }
                    
                    for (const [dr, dc, fromDir, toDir] of directions) {
                        const newRow = currentRow + dr;
                        const newCol = currentCol + dc;
                        
                        // Check bounds
                        if (newRow < 0 || newRow >= height || newCol < 0 || newCol >= width) {
                            continue;
                        }
                        
                        // Check if already visited
                        if (visited[newRow][newCol]) {
                            continue;
                        }
                        
                        // Check if connected
                        if (this.connections[currentRow][currentCol][fromDir] && 
                            this.connections[newRow][newCol][toDir]) {
                            
                            visited[newRow][newCol] = true;
                            parent[newRow][newCol] = [currentRow, currentCol];
                            queue.push([newRow, newCol]);
                        }
                    }
                }
                
                // Reconstruct path
                const path = [];
                let current = end;
                
                while (current) {
                    path.unshift(current);
                    if (current[0] === start[0] && current[1] === start[1]) {
                        break;
                    }
                    current = parent[current[0]][current[1]];
                }
                
                return path.length > 1 ? path : [];
            }
            
            // Seal alternative paths by removing connections that create shortcuts
            sealAlternativePaths(mainPathCells) {
                let sealedCount = 0;
                
                // Iterate through all cells and find those that create alternative connections
                for (let row = 0; row < this.height; row++) {
                    for (let col = 0; col < this.width; col++) {
                        // Skip cells that are part of main path
                        if (mainPathCells.has(`${row},${col}`)) {
                            continue;
                        }
                        
                        // Check if this cell has connections that bypass the main path
                        if (this.hasAlternativeConnections(row, col, mainPathCells)) {
                            if (this.canSealCell(row, col, mainPathCells)) {
                                this.sealCell(row, col);
                                sealedCount++;
                            }
                        }
                    }
                }
                
                return sealedCount;
            }
            
            // Simple and efficient method to block shortcut cells
            blockShortcutCells(mainPathCells) {
                let blockedCount = 0;
                
                // Check each cell to see if it creates shortcuts
                for (let row = 1; row < this.height - 1; row++) {
                    for (let col = 1; col < this.width - 1; col++) {
                        // Skip main path cells
                        if (mainPathCells.has(`${row},${col}`)) {
                            continue;
                        }
                        
                        // Check if this cell is connected to main path from multiple sides
                        if (this.isShortcutCell(row, col, mainPathCells)) {
                            this.sealCell(row, col);
                            blockedCount++;
                            console.log(`Blocked shortcut cell at (${row}, ${col})`);
                            
                            // Limit the number of cells we block to avoid over-blocking
                            if (blockedCount >= 20) {
                                break;
                            }
                        }
                    }
                    if (blockedCount >= 20) {
                        break;
                    }
                }
                
                return blockedCount;
            }
            
            // Check if a cell creates shortcuts by connecting to main path from multiple directions
            isShortcutCell(row, col, mainPathCells) {
                // Don't seal cells that are too close to entrance or exit
                if ((row <= 2 && col <= 2) || 
                    (row >= this.height - 3 && col >= this.width - 3)) {
                    return false;
                }
                
                const directions = [
                    [-1, 0, 'up'],
                    [1, 0, 'down'],
                    [0, -1, 'left'],
                    [0, 1, 'right']
                ];
                
                let mainPathConnections = 0;
                let connectedMainPathCells = [];
                
                for (const [dr, dc, dir] of directions) {
                    const adjRow = row + dr;
                    const adjCol = col + dc;
                    
                    // Check bounds
                    if (adjRow < 0 || adjRow >= this.height || adjCol < 0 || adjCol >= this.width) {
                        continue;
                    }
                    
                    // Check if connected to this adjacent cell and if adjacent cell is on main path
                    if (this.connections[row][col][dir] && mainPathCells.has(`${adjRow},${adjCol}`)) {
                        mainPathConnections++;
                        connectedMainPathCells.push([adjRow, adjCol]);
                    }
                }
                
                // If connected to main path from 2+ directions, check if they are far apart
                if (mainPathConnections >= 2) {
                    // Make sure the connected main path cells are not adjacent to each other
                    // (to avoid breaking critical path segments)
                    for (let i = 0; i < connectedMainPathCells.length; i++) {
                        for (let j = i + 1; j < connectedMainPathCells.length; j++) {
                            const [r1, c1] = connectedMainPathCells[i];
                            const [r2, c2] = connectedMainPathCells[j];
                            const distance = Math.abs(r1 - r2) + Math.abs(c1 - c2);
                            
                            // If connected main path cells are far apart, it's likely a shortcut
                            if (distance > 2) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            // Check if a cell can be safely sealed without breaking main path connectivity
            canSealCell(row, col, mainPathCells) {
                // Don't seal cells that are part of the main path
                if (mainPathCells.has(`${row},${col}`)) {
                    return false;
                }
                
                // Don't seal entrance or exit
                if ((row === 0 && col === 0) || (row === this.height - 1 && col === this.width - 1)) {
                    return false;
                }
                
                // Check if sealing this cell would isolate any important areas
                // For simplicity, we'll seal cells that are not critical junctions
                const connectionCount = Object.values(this.connections[row][col]).filter(Boolean).length;
                
                // If the cell has only 1 or 2 connections, it's likely safe to seal
                // Cells with 3+ connections are junctions and should be preserved
                return connectionCount <= 2;
            }
            
            // Seal a cell by removing all its connections
            sealCell(row, col) {
                // Remove all connections from this cell
                const directions = [
                    [-1, 0, 'up', 'down'],
                    [1, 0, 'down', 'up'],
                    [0, -1, 'left', 'right'],
                    [0, 1, 'right', 'left']
                ];
                
                for (const [dr, dc, fromDir, toDir] of directions) {
                    const adjRow = row + dr;
                    const adjCol = col + dc;
                    
                    // Remove connection from current cell
                    this.connections[row][col][fromDir] = false;
                    
                    // Remove corresponding connection from adjacent cell if it exists
                    if (adjRow >= 0 && adjRow < this.height && adjCol >= 0 && adjCol < this.width) {
                        this.connections[adjRow][adjCol][toDir] = false;
                    }
                }
                
                console.log(`Sealed cell at (${row}, ${col})`);
            }
        }

        function renderMaze(data) {
            const maze = data.maze || data;
            const connections = data.connections;
            
            const mazeElement = document.getElementById('maze');
            // 保留滑动指示器，只清空迷宫内容
            const swipeIndicator = document.getElementById('swipeIndicator');
            mazeElement.innerHTML = '';
            if (swipeIndicator) {
                mazeElement.appendChild(swipeIndicator);
            } else {
                // 如果指示器不存在，创建一个
                const newIndicator = document.createElement('div');
                newIndicator.className = 'swipe-indicator';
                newIndicator.id = 'swipeIndicator';
                mazeElement.appendChild(newIndicator);
            }
            
            const height = maze.length;
            const width = maze[0].length;
            
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.position = 'relative';
                    
                    // All cells are either walls or paths, no special entrance/exit colors
                    if (maze[i][j] === 1) {
                        cell.classList.add('wall');
                    } else {
                        cell.classList.add('path');
                    }
                    
                    // Add connection walls for all cells (both path and wall) if we have connection data
                    if (connections && connections[i] && connections[i][j]) {
                        const conn = connections[i][j];
                        
                        // Helper function to check if a cell is completely sealed (no connections in any direction)
                        function isCellSealed(row, col) {
                            if (connections[row] && connections[row][col]) {
                                const cellConn = connections[row][col];
                                return !cellConn.up && !cellConn.down && !cellConn.left && !cellConn.right;
                            }
                            return true; // If no connection data, assume sealed
                        }
                        
                        // Add walls for blocked directions, but skip outer boundary walls at entrance and exit
                        // Also skip walls between two completely sealed cells
                        // To avoid double-rendering, only render walls on specific edges:
                        // - Top walls: only render on the upper cell (smaller row index)
                        // - Left walls: only render on the left cell (smaller column index)
                        
                        // Helper function to check if we should render a wall between two cells
                        function shouldRenderWall(currentRow, currentCol, adjRow, adjCol) {
                            // Skip if both cells are completely sealed
                            if (isCellSealed(currentRow, currentCol) && isCellSealed(adjRow, adjCol)) {
                                return false;
                            }
                            
                            // Skip entrance/exit boundary openings
                            if ((currentRow === 0 && currentCol === 0) || (adjRow === 0 && adjCol === 0)) {
                                return false; // Skip entrance boundaries
                            }
                            if ((currentRow === height - 1 && currentCol === width - 1) || (adjRow === height - 1 && adjCol === width - 1)) {
                                return false; // Skip exit boundaries
                            }
                            
                            // Check if there's a wall between the cells
                            if (connections[currentRow] && connections[currentRow][currentCol] &&
                                connections[adjRow] && connections[adjRow][adjCol]) {
                                const currentConn = connections[currentRow][currentCol];
                                const adjConn = connections[adjRow][adjCol];
                                
                                // Determine direction and check connections
                                if (adjRow === currentRow - 1) { // Adjacent cell is above
                                    return !currentConn.up || !adjConn.down;
                                } else if (adjCol === currentCol - 1) { // Adjacent cell is to the left
                                    return !currentConn.left || !adjConn.right;
                                }
                            }
                            return true;
                        }
                        
                        // Only render top walls (horizontal lines between vertically adjacent cells)
                        if (i > 0) { // Not the top row
                            if (shouldRenderWall(i, j, i - 1, j)) {
                                const wallTop = document.createElement('div');
                                wallTop.style.position = 'absolute';
                                wallTop.style.top = '0';
                                wallTop.style.left = '0';
                                wallTop.style.width = '100%';
                                wallTop.style.height = '1px';
                                wallTop.style.backgroundColor = '#000';
                                cell.appendChild(wallTop);
                            }
                        }
                        
                        // Only render left walls (vertical lines between horizontally adjacent cells)
                        if (j > 0) { // Not the leftmost column
                            if (shouldRenderWall(i, j, i, j - 1)) {
                                const wallLeft = document.createElement('div');
                                wallLeft.style.position = 'absolute';
                                wallLeft.style.top = '0';
                                wallLeft.style.left = '0';
                                wallLeft.style.width = '1px';
                                wallLeft.style.height = '100%';
                                wallLeft.style.backgroundColor = '#000';
                                cell.appendChild(wallLeft);
                            }
                        }
                        
                        // Add outer boundaries (edges of the maze)
                        // Top boundary
                        if (i === 0 && !(i === 0 && j === 0)) { // Top edge, but not entrance
                            const wallTop = document.createElement('div');
                            wallTop.style.position = 'absolute';
                            wallTop.style.top = '0';
                            wallTop.style.left = '0';
                            wallTop.style.width = '100%';
                            wallTop.style.height = '1px';
                            wallTop.style.backgroundColor = '#000';
                            cell.appendChild(wallTop);
                        }
                        
                        // Bottom boundary
                        if (i === height - 1 && !(i === height - 1 && j === width - 1)) { // Bottom edge, but not exit
                            const wallBottom = document.createElement('div');
                            wallBottom.style.position = 'absolute';
                            wallBottom.style.bottom = '0';
                            wallBottom.style.left = '0';
                            wallBottom.style.width = '100%';
                            wallBottom.style.height = '1px';
                            wallBottom.style.backgroundColor = '#000';
                            cell.appendChild(wallBottom);
                        }
                        
                        // Left boundary
                        if (j === 0 && !(i === 0 && j === 0)) { // Left edge, but not entrance
                            const wallLeft = document.createElement('div');
                            wallLeft.style.position = 'absolute';
                            wallLeft.style.top = '0';
                            wallLeft.style.left = '0';
                            wallLeft.style.width = '1px';
                            wallLeft.style.height = '100%';
                            wallLeft.style.backgroundColor = '#000';
                            cell.appendChild(wallLeft);
                        }
                        
                        // Right boundary
                        if (j === width - 1 && !(i === height - 1 && j === width - 1)) { // Right edge, but not exit
                            const wallRight = document.createElement('div');
                            wallRight.style.position = 'absolute';
                            wallRight.style.top = '0';
                            wallRight.style.right = '0';
                            wallRight.style.width = '1px';
                            wallRight.style.height = '100%';
                            wallRight.style.backgroundColor = '#000';
                            cell.appendChild(wallRight);
                        }
                    }
                    
                    mazeElement.appendChild(cell);
                }
            }
        }

        let currentMaze = null;
        let currentConnections = null;
        let solutionPath = [];
        let currentSize = 50;
        let playerPosition = { row: 0, col: 0 }; // 小人当前位置

        function setMazeSize(size) {
            currentSize = size;
            
            // Update active button
            document.querySelectorAll('.size-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`size-${size}`).classList.add('active');
            
            // Update maze grid CSS
            updateMazeGridCSS(size);
            
            // Generate new maze with the selected size
            generateMaze();
        }
        
        function updateMazeGridCSS(size) {
            // 响应式格子大小计算
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const maxMazeWidth = Math.min(viewportWidth * 0.95, 800);
            const maxMazeHeight = Math.min(viewportHeight * 0.7, 600);
            
            // 根据屏幕大小和迷宫大小计算最优格子大小
            const cellSizeByWidth = Math.floor(maxMazeWidth / size);
            const cellSizeByHeight = Math.floor(maxMazeHeight / size);
            const cellSize = Math.max(2, Math.min(cellSizeByWidth, cellSizeByHeight, 15));
            
            const mazeElement = document.getElementById('maze');
            mazeElement.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
            mazeElement.style.gridTemplateRows = `repeat(${size}, ${cellSize}px)`;
            
            // Update cell size in CSS
            const styleSheet = document.styleSheets[0];
            // Find and update the .cell rule
            for (let i = 0; i < styleSheet.cssRules.length; i++) {
                const rule = styleSheet.cssRules[i];
                if (rule.selectorText === '.cell') {
                    rule.style.width = `${cellSize}px`;
                    rule.style.height = `${cellSize}px`;
                    break;
                }
            }
        }

        function generateMaze() {
            const generator = new MazeGenerator(currentSize, currentSize);
            const mazeData = generator.generate();
            currentMaze = mazeData.maze;
            currentConnections = mazeData.connections;
            solutionPath = [];
            // 重置小人位置到入口
            playerPosition = { row: 0, col: 0 };
            // Render the complete maze with connections
            renderMaze({maze: mazeData.maze, connections: mazeData.connections});
            // 显示小人
            updatePlayerDisplay();
        }

        function findPath(maze, connections) {
            const height = maze.length;
            const width = maze[0].length;
            const start = [0, 0]; // Use actual entrance
            const end = [height - 1, width - 1]; // Use actual exit
            
            console.log(`Searching path from (${start[0]}, ${start[1]}) to (${end[0]}, ${end[1]})`);
            console.log(`Maze size: ${height}x${width}`);
            
            // Debug entrance connections
            console.log("Entrance (0,0) connections:", connections[0][0]);
            console.log("Exit connections:", connections[height-1][width-1]);
            
            // Check if entrance can move to adjacent cells
            console.log("Can move from entrance to (0,1):", connections[0][0].right && connections[0][1] && connections[0][1].left);
            console.log("Can move from entrance to (1,0):", connections[0][0].down && connections[1][0] && connections[1][0].up);
            
            // Helper function to check if two adjacent cells are connected
            function canMove(fromRow, fromCol, toRow, toCol) {
                // Special handling for entrance and exit
                const isEntrance = (r, c) => r === 0 && c === 0;
                const isExit = (r, c) => r === height - 1 && c === width - 1;
                
                // Allow movement to/from entrance and exit regardless of maze cell value
                if (!isEntrance(fromRow, fromCol) && !isExit(fromRow, fromCol) && maze[fromRow][fromCol] !== 0) {
                    return false;
                }
                if (!isEntrance(toRow, toCol) && !isExit(toRow, toCol) && maze[toRow][toCol] !== 0) {
                    return false;
                }
                
                // Check connections based on direction
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;
                
                // Check if we have connection data for both cells
                if (!connections[fromRow] || !connections[fromRow][fromCol] || 
                    !connections[toRow] || !connections[toRow][toCol]) {
                    return false;
                }
                
                if (rowDiff === -1 && colDiff === 0) { // Moving up
                    return connections[fromRow][fromCol].up && connections[toRow][toCol].down;
                } else if (rowDiff === 1 && colDiff === 0) { // Moving down
                    return connections[fromRow][fromCol].down && connections[toRow][toCol].up;
                } else if (rowDiff === 0 && colDiff === -1) { // Moving left
                    return connections[fromRow][fromCol].left && connections[toRow][toCol].right;
                } else if (rowDiff === 0 && colDiff === 1) { // Moving right
                    return connections[fromRow][fromCol].right && connections[toRow][toCol].left;
                }
                
                return false;
            }
            
            // BFS to find shortest path using connection information
            const queue = [start];
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            const parent = Array(height).fill().map(() => Array(width).fill(null));
            
            visited[start[0]][start[1]] = true;
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                
                if (x === end[0] && y === end[1]) {
                    break;
                }
                
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < height && ny >= 0 && ny < width && 
                        !visited[nx][ny] && canMove(x, y, nx, ny)) {
                        visited[nx][ny] = true;
                        parent[nx][ny] = [x, y];
                        queue.push([nx, ny]);
                    }
                }
            }
            
            // Reconstruct path
            const path = [];
            let current = end;
            
            // Check if we found a path
            if (!parent[end[0]][end[1]] && !(end[0] === start[0] && end[1] === start[1])) {
                return [];
            }
            
            // Trace back from end to start
            while (current) {
                path.unshift(current);
                if (current[0] === start[0] && current[1] === start[1]) {
                    break;
                }
                current = parent[current[0]][current[1]];
            }
            
            return path;
        }

        function showPath() {
            if (!currentMaze || !currentConnections) {
                console.log("No maze or connections data");
                return;
            }
            
            console.log("Finding path...");
            solutionPath = findPath(currentMaze, currentConnections);
            console.log("Path found:", solutionPath.length, "steps");
            
            if (solutionPath.length === 0) {
                console.log("No path found!");
                return;
            }
            
            const cells = document.querySelectorAll('.cell');
            const width = currentSize;
            
            solutionPath.forEach(([x, y]) => {
                const index = x * width + y;
                if (cells[index]) {
                    cells[index].classList.add('solution');
                }
            });
            
            console.log("Path displayed successfully");
        }

        function hidePath() {
            const cells = document.querySelectorAll('.solution');
            cells.forEach(cell => {
                cell.classList.remove('solution');
            });
        }

        // 响应式处理
        function handleResize() {
            updateMazeGridCSS(currentSize);
        }
        
        // Initialize with default size and generate initial maze
        window.addEventListener('DOMContentLoaded', function() {
            updateMazeGridCSS(currentSize);
            generateMaze();
            initTouchEvents(); // 初始化触摸事件
        });
        
        // 监听窗口大小变化
        window.addEventListener('resize', handleResize);
        
        // 监听屏幕方向变化（移动设备）
        window.addEventListener('orientationchange', function() {
            setTimeout(handleResize, 100); // 延迟一点执行，等待方向变化完成
        });
        
        // 更新小人显示位置
        function updatePlayerDisplay() {
            // 移除所有现有的小人标记
            document.querySelectorAll('.player').forEach(cell => {
                cell.classList.remove('player');
            });
            
            // 在当前位置添加小人标记
            const cells = document.querySelectorAll('.cell');
            const index = playerPosition.row * currentSize + playerPosition.col;
            if (cells[index]) {
                cells[index].classList.add('player');
            }
        }
        
        // 检查两个相邻格子是否连通
        function canMove(fromRow, fromCol, toRow, toCol) {
            if (!currentMaze || !currentConnections) {
                return false;
            }
            
            // 检查是否为相邻格子
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            if (!((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1))) {
                return false;
            }
            
            // 检查边界
            if (toRow < 0 || toRow >= currentSize || toCol < 0 || toCol >= currentSize) {
                return false;
            }
            
            // 简化逻辑：直接使用connections数据判断
            const fromConnections = currentConnections[fromRow][fromCol];
            const toConnections = currentConnections[toRow][toCol];
            
            // 根据移动方向检查连接
            if (toRow === fromRow - 1) { // 向上移动
                return fromConnections.up && toConnections.down;
            } else if (toRow === fromRow + 1) { // 向下移动
                return fromConnections.down && toConnections.up;
            } else if (toCol === fromCol - 1) { // 向左移动
                return fromConnections.left && toConnections.right;
            } else if (toCol === fromCol + 1) { // 向右移动
                return fromConnections.right && toConnections.left;
            }
            
            return false;
        }
        
        // 跳跃到下一个路口的移动算法
        function findNextIntersection(row, col, direction) {
            const directions = {
                'up': [-1, 0],
                'down': [1, 0],
                'left': [0, -1],
                'right': [0, 1]
            };
            
            if (!directions[direction]) return null;
            
            const [dRow, dCol] = directions[direction];
            let currentRow = row;
            let currentCol = col;
            
            // 先检查是否可以在该方向移动
            if (!canMove(currentRow, currentCol, currentRow + dRow, currentCol + dCol)) {
                return null;
            }
            
            // 继续在该方向移动，直到达到路口
            while (true) {
                const nextRow = currentRow + dRow;
                const nextCol = currentCol + dCol;
                
                // 检查是否可以移动到下一个位置
                if (!canMove(currentRow, currentCol, nextRow, nextCol)) {
                    break;
                }
                
                // 移动到下一个位置
                currentRow = nextRow;
                currentCol = nextCol;
                
                // 检查是否到达路口
                if (isIntersection(currentRow, currentCol)) {
                    break;
                }
            }
            
            // 如果位置没有变化，说明无法移动
            if (currentRow === row && currentCol === col) {
                return null;
            }
            
            return { row: currentRow, col: currentCol };
        }
        
        // 检查是否为路口（有多个可选方向或是特殊位置）
        function isIntersection(row, col) {
            if (!currentConnections) return false;
            
            // 入口和出口总是路口
            if ((row === 0 && col === 0) || (row === currentSize - 1 && col === currentSize - 1)) {
                return true;
            }
            
            // 计算可用方向数
            let availableDirections = 0;
            if (canMove(row, col, row - 1, col)) availableDirections++; // 上
            if (canMove(row, col, row + 1, col)) availableDirections++; // 下
            if (canMove(row, col, row, col - 1)) availableDirections++; // 左
            if (canMove(row, col, row, col + 1)) availableDirections++; // 右
            
            // 如果有超过2个方向可选，则认为是路口
            // 或者只有1个方向（死胡同）也认为是路口
            return availableDirections !== 2;
        }
        
        // 移动小人（跳跃到路口）
        function movePlayer(direction) {
            if (!currentMaze || !currentConnections) {
                return;
            }
            
            const newPos = findNextIntersection(playerPosition.row, playerPosition.col, direction);
            
            if (newPos) {
                // 添加平滑移动动画
                animatePlayerMovement(playerPosition, newPos, () => {
                    playerPosition = newPos;
                    updatePlayerDisplay();
                    
                    // 检查是否到达出口
                    if (playerPosition.row === currentSize - 1 && playerPosition.col === currentSize - 1) {
                        setTimeout(() => {
                            alert('恭喜！你成功走出了迷宫！');
                        }, 100);
                    }
                });
            }
        }
        
        // 平滑移动动画
        let isMoving = false;
        
        function animatePlayerMovement(fromPos, toPos, callback) {
            if (isMoving) return; // 防止重复移动
            isMoving = true;
            
            const steps = Math.max(Math.abs(toPos.row - fromPos.row), Math.abs(toPos.col - fromPos.col));
            const stepDuration = 100; // 每步的时间（毫秒）
            const rowStep = (toPos.row - fromPos.row) / steps;
            const colStep = (toPos.col - fromPos.col) / steps;
            
            let currentStep = 0;
            
            function animateStep() {
                currentStep++;
                const currentRow = Math.round(fromPos.row + rowStep * currentStep);
                const currentCol = Math.round(fromPos.col + colStep * currentStep);
                
                // 更新显示位置
                const tempPos = { row: currentRow, col: currentCol };
                const originalPos = playerPosition;
                playerPosition = tempPos;
                updatePlayerDisplay();
                playerPosition = originalPos;
                
                if (currentStep < steps) {
                    setTimeout(animateStep, stepDuration);
                } else {
                    isMoving = false;
                    callback();
                }
            }
            
            animateStep();
        }
        
        // 键盘事件监听
        document.addEventListener('keydown', function(event) {
            if (isMoving) return; // 移动中不响应按键
            
            switch(event.key) {
                case 'ArrowUp':
                    event.preventDefault();
                    movePlayer('up');
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    movePlayer('down');
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    movePlayer('left');
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    movePlayer('right');
                    break;
            }
        });
        
        // 触摸手势支持
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const minSwipeDistance = 30; // 最小滑动距离
        
        function handleTouchStart(event) {
            if (isMoving) return;
            
            event.preventDefault();
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }
        
        function handleTouchMove(event) {
            if (isMoving) return;
            
            event.preventDefault();
            const touch = event.touches[0];
            touchEndX = touch.clientX;
            touchEndY = touch.clientY;
            
            // 实时显示滑动方向指示器
            showSwipeIndicator();
        }
        
        function handleTouchEnd(event) {
            if (isMoving) return;
            
            event.preventDefault();
            hideSwipeIndicator();
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);
            
            // 检查是否达到最小滑动距离
            if (Math.max(absDeltaX, absDeltaY) < minSwipeDistance) {
                return;
            }
            
            // 判断滑动方向
            if (absDeltaX > absDeltaY) {
                // 水平滑动
                if (deltaX > 0) {
                    movePlayer('right');
                } else {
                    movePlayer('left');
                }
            } else {
                // 垂直滑动
                if (deltaY > 0) {
                    movePlayer('down');
                } else {
                    movePlayer('up');
                }
            }
        }
        
        function showSwipeIndicator() {
            const indicator = document.getElementById('swipeIndicator');
            if (!indicator) return; // 安全检查
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);
            
            if (Math.max(absDeltaX, absDeltaY) < minSwipeDistance) {
                indicator.style.opacity = '0';
                return;
            }
            
            let arrow = '';
            if (absDeltaX > absDeltaY) {
                arrow = deltaX > 0 ? '→' : '←';
            } else {
                arrow = deltaY > 0 ? '↓' : '↑';
            }
            
            indicator.textContent = arrow;
            indicator.style.opacity = '0.7';
        }
        
        function hideSwipeIndicator() {
            const indicator = document.getElementById('swipeIndicator');
            if (indicator) { // 安全检查
                indicator.style.opacity = '0';
            }
        }
        
        // 初始化触摸事件监听
        function initTouchEvents() {
            const mazeElement = document.getElementById('maze');
            if (mazeElement) {
                mazeElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                mazeElement.addEventListener('touchmove', handleTouchMove, { passive: false });
                mazeElement.addEventListener('touchend', handleTouchEnd, { passive: false });
                mazeElement.addEventListener('touchcancel', hideSwipeIndicator);
            }
        }
        
        // 防止默认的滚动和缩放行为
        document.addEventListener('touchmove', function(event) {
            if (event.target.closest('#maze')) {
                event.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>

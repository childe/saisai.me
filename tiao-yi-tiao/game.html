<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 跳一跳 - 终极交互版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: 'Arial', sans-serif; }
        #score-container {
            position: absolute; top: 20px; left: 20px; color: #333; font-size: 24px; font-weight: bold; pointer-events: none; user-select: none;
        }
        #info {
            font-size: 14px; color: #666; margin-top: 5px;
        }
        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95); padding: 40px; border-radius: 12px;
            text-align: center; display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.2); z-index: 10;
        }
        button {
            background: #28a745; color: white; border: none; padding: 10px 30px;
            font-size: 18px; border-radius: 5px; cursor: pointer; margin-top: 20px;
        }
        button:hover { background: #218838; }
        .float-text {
            position: absolute; font-weight: bold; font-size: 20px; animation: floatUp 1.0s ease-out forwards; pointer-events: none; z-index: 5; text-shadow: 1px 1px 2px white;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-80px); }
        }
    </style>
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="score-container">
    得分: <span id="score">0</span>
    <div id="info">连续命中中心，音调会越来越高！</div>
</div>

<div id="game-over">
    <h2 style="margin:0 0 10px 0;">游戏结束</h2>
    <p>本次得分: <span id="final-score" style="font-size: 24px; color: #d9534f; font-weight:bold;">0</span></p>
    <button onclick="restartGame()">重新开始</button>
</div>

<script>
    // --- 游戏配置 ---
    const CONFIG = {
        cubeSize: 4,
        heroSize: 1.6, 
        maxDistance: 12,  
        compressionSpeed: 0.01, 
        gravity: 0.04, 
        jumpHeight: 0.7, 
        
        types: [
            { id: 'normal', color: 0xffffff, score: 0, shape: 'box', prob: 0.4 }, 
            { id: 'store', color: 0x4fc3f7, score: 15, shape: 'box', prob: 0.2, name: "便利店" }, 
            { id: 'rubik', color: 0xff5252, score: 10, shape: 'box', prob: 0.2, name: "魔方" }, 
            { id: 'music', color: 0xff9800, score: 30, shape: 'cylinder', prob: 0.2, name: "音乐盒" } 
        ]
    };

    // --- 全局变量 ---
    let scene, camera, renderer;
    let hero;
    let blocks = [];
    let particles = []; 
    let score = 0;
    let state = 'ready'; 
    let compression = 1; 
    let jumpVelocity = { x: 0, y: 0, z: 0 };
    let currentBlockIndex = 0;
    let heroSkinUnlocked = false;
    let comboCount = 0; // ✨ 新增：记录连击次数

    // 动画相关
    let activeRubikAnimations = []; // 存储正在旋转的魔方

    // 音频上下文
    let audioCtx;
    let chargeOscillator = null;
    let chargeGainNode = null;

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee);

        const aspect = window.innerWidth / window.innerHeight;
        const d = 20;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(10, 20, 0);
        dirLight.castShadow = true;
        scene.add(dirLight);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('touchstart', onMouseDown, {passive: false});
        window.addEventListener('touchend', onMouseUp, {passive: false});

        startGame();
        animate();
    }

    // --- 音频系统 ---
    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    function startChargeSound() {
        initAudio();
        if (chargeOscillator) return;

        chargeOscillator = audioCtx.createOscillator();
        chargeGainNode = audioCtx.createGain();
        
        chargeOscillator.type = 'sine';
        chargeOscillator.frequency.setValueAtTime(400, audioCtx.currentTime); // 初始频率
        
        // 创建一个 LFO 来制作 "滴滴滴" 的颤音效果
        const lfo = audioCtx.createOscillator();
        lfo.type = 'square';
        lfo.frequency.value = 8; // 每秒8次
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 500; 

        lfo.connect(lfoGain);
        
        chargeOscillator.connect(chargeGainNode);
        chargeGainNode.connect(audioCtx.destination);
        
        chargeGainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        chargeOscillator.start();
    }

    function updateChargeSound(compressionLevel) {
        if (chargeOscillator && audioCtx) {
            // 随着蓄力（compression 变小），频率升高
            const freq = 400 + (1 - compressionLevel) * 400; 
            chargeOscillator.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.1);
            
            // 模拟 "滴滴滴" 的断续感
            const time = audioCtx.currentTime;
            const volume = (Math.sin(time * 20) > 0) ? 0.1 : 0;
            chargeGainNode.gain.setTargetAtTime(volume, time, 0.01);
        }
    }

    function stopChargeSound() {
        if (chargeOscillator) {
            // 平滑停止
            chargeGainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            chargeOscillator.stop(audioCtx.currentTime + 0.1);
            chargeOscillator = null;
            chargeGainNode = null;
        }
    }

    function playMusicBoxMelody() {
        initAudio();
        const notes = [523.25, 659.25, 783.99, 1046.50, 783.99, 659.25]; // C E G C G E
        const duration = 0.15;
        let startTime = audioCtx.currentTime;

        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle'; // 八音盒音色接近三角波
            osc.frequency.value = freq;
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start(startTime + i * duration);
            
            // 包络：快速起音，慢速衰减
            gain.gain.setValueAtTime(0, startTime + i * duration);
            gain.gain.linearRampToValueAtTime(0.2, startTime + i * duration + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + i * duration + 0.4);
            
            osc.stop(startTime + i * duration + 0.5);
        });
    }

    // ✨ 新增：中心命中音效（音调随连击升高）
    function playCenterHitSound(combo) {
        initAudio();
        
        // 创建两个振荡器来模拟金属撞击的“咣”声（稍微失谐）
        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc1.type = 'triangle';
        osc2.type = 'sine';

        // 计算音调：基础频率 C5 (523.25Hz)，每连击一次升高一个半音（约1.06倍）
        // 限制最高音调，防止过于刺耳（比如限制在15连击）
        const pitchStep = Math.min(combo, 15);
        const baseFreq = 523.25; 
        const freq = baseFreq * Math.pow(1.05946, pitchStep); 

        osc1.frequency.setValueAtTime(freq, audioCtx.currentTime);
        osc2.frequency.setValueAtTime(freq * 1.5, audioCtx.currentTime); // 五度音程增加厚度

        osc1.connect(gain);
        osc2.connect(gain);
        gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;
        osc1.start(now);
        osc2.start(now);

        // 打击感包络：瞬间起音，然后快速衰减
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.4, now + 0.02); // 冲击
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5); // 尾韵

        osc1.stop(now + 0.6);
        osc2.stop(now + 0.6);
    }

    // --- 游戏逻辑 ---

    function startGame() {
        blocks.forEach(b => scene.remove(b.mesh));
        particles.forEach(p => scene.remove(p.mesh));
        particles = [];
        activeRubikAnimations = [];

        if (hero) scene.remove(hero);
        blocks = [];
        
        score = 0;
        comboCount = 0; // 重置连击
        heroSkinUnlocked = false;
        updateScoreUI();
        document.getElementById('game-over').style.display = 'none';

        createBlock(0, 0, 'normal');
        createBlock(-8, 0); 

        createHero();
        
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);
        
        state = 'ready';
        currentBlockIndex = 0;
    }

    // ... (createHero, checkSkinUnlock, spawnParticle, updateParticles 保持不变) ...
    function createHero() {
        hero = new THREE.Group();
        const material = new THREE.MeshLambertMaterial({ color: 0x333333 }); 
        const bodyGeo = new THREE.CylinderGeometry(0.28, 0.35, 1.1, 32); 
        const bodyMesh = new THREE.Mesh(bodyGeo, material);
        bodyMesh.position.y = -0.1; 
        bodyMesh.castShadow = true;
        hero.add(bodyMesh);
        const headGeo = new THREE.SphereGeometry(0.32, 32, 32);
        const headMesh = new THREE.Mesh(headGeo, material);
        headMesh.position.y = 0.75; 
        headMesh.castShadow = true;
        hero.add(headMesh);
        hero.position.set(0, CONFIG.cubeSize/2 + CONFIG.heroSize/2, 0);
        scene.add(hero);
    }
    
    function checkSkinUnlock() {
        if (score >= 100 && !heroSkinUnlocked) {
            heroSkinUnlocked = true;
            const goldMat = new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0x332200, specular: 0xffffff, shininess: 100 });
            hero.children.forEach(child => child.material = goldMat);
            showFloatText("新皮肤解锁！", window.innerWidth/2, window.innerHeight/2 - 100, '#FFD700');
        }
    }

    function spawnParticle() {
        const range = 0.4;
        const x = hero.position.x + (Math.random() - 0.5) * range;
        const y = hero.position.y + (Math.random() - 0.5) * range;
        const z = hero.position.z + (Math.random() - 0.5) * range;
        const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFD700, transparent: true, opacity: 0.8 });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, z);
        mesh.rotation.x = Math.random() * Math.PI;
        mesh.rotation.y = Math.random() * Math.PI;
        scene.add(mesh);
        particles.push({ mesh: mesh, life: 1.0 });
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life -= 0.03; 
            p.mesh.rotation.x += 0.1;
            p.mesh.rotation.y += 0.1;
            p.mesh.scale.setScalar(p.life);
            p.mesh.material.opacity = p.life;
            if (p.life <= 0) {
                scene.remove(p.mesh);
                particles.splice(i, 1);
            }
        }
    }

    // --- 特殊方块生成与效果 ---

    // 魔方：增加 tag 标记顶层
    function createRubikMesh(size) {
        const group = new THREE.Group();
        const segments = 3;
        const gap = 0.08;
        const subSize = (size / segments) - gap;
        const offset = size / segments;
        const colors = [0xffffff, 0xffd500, 0x009e60, 0x0051ba, 0xc41e3a, 0xff5800];

        const innerCore = new THREE.Mesh(new THREE.BoxGeometry(size - 0.1, size - 0.1, size - 0.1), new THREE.MeshBasicMaterial({ color: 0x000000 }));
        group.add(innerCore);
        
        const geometry = new THREE.BoxGeometry(subSize, subSize, subSize);
        
        for(let x = 0; x < segments; x++) {
            for(let y = 0; y < segments; y++) {
                for(let z = 0; z < segments; z++) {
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const material = new THREE.MeshLambertMaterial({ color: color });
                    const voxel = new THREE.Mesh(geometry, material);
                    // 实际坐标
                    voxel.position.set((x - 1) * offset, (y - 1) * offset, (z - 1) * offset);
                    
                    // 标记：如果 y 是最高层 (y=2 => 索引)，标记为顶层
                    if (y === 2) {
                        voxel.userData.isTopLayer = true;
                    }
                    
                    voxel.castShadow = true;
                    voxel.receiveShadow = true;
                    group.add(voxel);
                }
            }
        }
        return group;
    }

    // 触发魔方动画
    function triggerRubikAnimation(rubikGroup) {
        // 创建一个 pivot (轴心)，将顶层方块 attach 到这个轴心上，旋转轴心，再 detach
        const pivot = new THREE.Group();
        pivot.position.y = CONFIG.cubeSize / 3; // 轴心位置大概在顶层下方一点
        rubikGroup.add(pivot);

        const topVoxels = [];
        rubikGroup.children.forEach(child => {
            if (child.userData.isTopLayer) {
                topVoxels.push(child);
            }
        });

        // 手动模拟 attach
        topVoxels.forEach(voxel => {
            pivot.attach(voxel);
        });

        activeRubikAnimations.push({
            pivot: pivot,
            targetRotation: Math.PI / 2, // 旋转 90 度
            currentRotation: 0,
            speed: 0.1
        });
    }

    // 便利店：给玻璃材质命名，方便查找
    function createStoreMesh(size) {
        const group = new THREE.Group();
        const mainGeo = new THREE.BoxGeometry(size, size, size);
        const mainMat = new THREE.MeshLambertMaterial({ color: 0xffffff }); 
        const mainMesh = new THREE.Mesh(mainGeo, mainMat);
        mainMesh.receiveShadow = true;
        mainMesh.castShadow = true;
        group.add(mainMesh);

        const stripeHeight = size * 0.05;
        const stripeDepth = size + 0.05; 
        const stripeGeo = new THREE.BoxGeometry(stripeDepth, stripeHeight, stripeDepth);
        const stripe1 = new THREE.Mesh(stripeGeo, new THREE.MeshLambertMaterial({ color: 0xFF6F00 })); 
        stripe1.position.y = size/2 - stripeHeight * 0.8;
        group.add(stripe1);
        const stripe2 = new THREE.Mesh(stripeGeo, new THREE.MeshLambertMaterial({ color: 0x007E33 })); 
        stripe2.position.y = size/2 - stripeHeight * 2.0;
        group.add(stripe2);
        const stripe3 = new THREE.Mesh(stripeGeo, new THREE.MeshLambertMaterial({ color: 0xCC0000 })); 
        stripe3.position.y = size/2 - stripeHeight * 3.2;
        group.add(stripe3);

        const doorHeight = size * 0.5;
        const doorWidth = size * 0.6;
        const doorMat = new THREE.MeshLambertMaterial({ 
            color: 0x87CEEB, 
            transparent: true, 
            opacity: 0.9,
            emissive: 0x000000 // 初始不发光
        });
        // 标记这个材质，方便后续点亮
        doorMat.userData.isGlass = true;

        const doorZ = new THREE.Mesh(new THREE.BoxGeometry(doorWidth, doorHeight, 0.1), doorMat);
        doorZ.position.set(0, -size/4, size/2 + 0.05);
        group.add(doorZ);

        const doorX = new THREE.Mesh(new THREE.BoxGeometry(0.1, doorHeight, doorWidth), doorMat);
        doorX.position.set(size/2 + 0.05, -size/4, 0);
        group.add(doorX);
        
        const signGeo = new THREE.BoxGeometry(size * 0.8, size * 0.1, size * 0.8);
        const signMesh = new THREE.Mesh(signGeo, new THREE.MeshLambertMaterial({ color: 0xeeeeee }));
        signMesh.position.y = size/2 + size * 0.05;
        group.add(signMesh);

        return group;
    }

    // 点亮便利店
    function lightUpStore(storeGroup) {
        storeGroup.traverse((child) => {
            if (child.material && child.material.userData && child.material.userData.isGlass) {
                // 变成暖黄色高亮
                child.material.color.setHex(0xFFFFE0);
                child.material.emissive.setHex(0xFFD700); 
                child.material.emissiveIntensity = 0.8;
                child.material.opacity = 1.0;
            }
        });
    }

    // 音乐盒生成保持不变
    function createMusicBoxMesh(size) {
        const group = new THREE.Group();
        const baseGeo = new THREE.BoxGeometry(size, size, size);
        const baseMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); 
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);
        const topY = size / 2;
        const diskRadius = size * 0.4;
        const diskHeight = 0.1;
        const diskGeo = new THREE.CylinderGeometry(diskRadius, diskRadius, diskHeight, 32);
        const diskMat = new THREE.MeshLambertMaterial({ color: 0x111111 }); 
        const disk = new THREE.Mesh(diskGeo, diskMat);
        disk.position.y = topY + diskHeight / 2;
        disk.receiveShadow = true;
        group.add(disk);
        const labelGeo = new THREE.CylinderGeometry(size * 0.15, size * 0.15, diskHeight + 0.02, 32);
        const labelMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 }); 
        const label = new THREE.Mesh(labelGeo, labelMat);
        label.position.y = topY + diskHeight / 2;
        group.add(label);
        const poleHeight = size * 0.5;
        const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, poleHeight, 8);
        const poleMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.8 }); 
        const pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.set(size * 0.35, topY + poleHeight / 2, -size * 0.35); 
        group.add(pole);
        const hornGeo = new THREE.ConeGeometry(size * 0.25, size * 0.6, 32, 1, true);
        const hornMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3, metalness: 0.8, side: THREE.DoubleSide });
        const horn = new THREE.Mesh(hornGeo, hornMat);
        horn.position.set(size * 0.2, topY + poleHeight + size * 0.2, -size * 0.2);
        const target = new THREE.Vector3(0, topY + size*0.5, size*0.5);
        horn.lookAt(target); 
        horn.rotation.x += Math.PI / 2; 
        group.add(horn);
        return group;
    }

    function createBlock(x, z, fixedType = null) {
        let typeData = CONFIG.types[0];
        if (!fixedType) {
            const rand = Math.random();
            let cumProb = 0;
            for (let t of CONFIG.types) {
                cumProb += t.prob;
                if (rand < cumProb) {
                    typeData = t;
                    break;
                }
            }
        } else {
            typeData = CONFIG.types.find(t => t.id === fixedType);
        }

        let mesh;
        if (typeData.id === 'rubik') {
            mesh = createRubikMesh(CONFIG.cubeSize);
        } else if (typeData.id === 'store') {
            mesh = createStoreMesh(CONFIG.cubeSize);
        } else if (typeData.id === 'music') {
            mesh = createMusicBoxMesh(CONFIG.cubeSize);
        } else {
            let geometry;
            if (typeData.shape === 'cylinder') {
                geometry = new THREE.CylinderGeometry(2, 2, CONFIG.cubeSize, 32);
            } else {
                geometry = new THREE.BoxGeometry(4, CONFIG.cubeSize, 4);
            }
            const material = new THREE.MeshLambertMaterial({ color: typeData.color });
            mesh = new THREE.Mesh(geometry, material);
            mesh.receiveShadow = true;
        }

        mesh.position.set(x, 0, z);
        scene.add(mesh);

        blocks.push({
            mesh: mesh,
            type: typeData,
            x: x,
            z: z
        });
    }

    function spawnNextBlock() {
        const prevBlock = blocks[blocks.length - 1];
        const distance = 4 + Math.random() * 6; 
        const direction = Math.random() > 0.5 ? 'x' : 'z';
        let nextX = prevBlock.x;
        let nextZ = prevBlock.z;
        if (direction === 'x') {
            nextX -= distance;
        } else {
            nextZ -= distance;
        }
        createBlock(nextX, nextZ);
        if (blocks.length > 10) {
            scene.remove(blocks[0].mesh);
            blocks.shift();
            currentBlockIndex--;
        }
    }

    function onMouseDown(e) {
        if (state === 'ready') {
            state = 'charging';
            compression = 1;
            // ⚡️ 1. 开始播放蓄力音效
            startChargeSound();
        }
    }

    function onMouseUp(e) {
        if (state === 'charging') {
            state = 'jumping';
            // ⚡️ 停止蓄力音效
            stopChargeSound();
            
            const power = 1 - compression; 
            const jumpTargetDist = power * CONFIG.maxDistance * 2.1; 
            const flightTimeInFrames = (2 * CONFIG.jumpHeight) / CONFIG.gravity;
            const horizontalSpeed = jumpTargetDist / flightTimeInFrames;

            hero.scale.y = 1;
            hero.position.y = CONFIG.cubeSize/2 + CONFIG.heroSize/2;

            const curr = blocks[currentBlockIndex];
            const next = blocks[currentBlockIndex + 1];
            
            const dx = next.x - curr.x;
            const dz = next.z - curr.z;
            const dist = Math.sqrt(dx*dx + dz*dz);
            
            jumpVelocity.x = (dx / dist) * horizontalSpeed; 
            jumpVelocity.z = (dz / dist) * horizontalSpeed;
            jumpVelocity.y = CONFIG.jumpHeight; 
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        if (state === 'charging') {
            if (compression > 0.5) {
                compression -= CONFIG.compressionSpeed; 
                hero.scale.y = compression;
                hero.position.y = (CONFIG.cubeSize/2) + (CONFIG.heroSize/2 * compression);
                // ⚡️ 更新音效频率
                updateChargeSound(compression);
            }
        }

        if (state === 'jumping') {
            hero.position.x += jumpVelocity.x; 
            hero.position.z += jumpVelocity.z;
            hero.position.y += jumpVelocity.y;
            jumpVelocity.y -= CONFIG.gravity; 
            hero.rotation.x -= jumpVelocity.z * 0.2;
            hero.rotation.z += jumpVelocity.x * 0.2;

            if (heroSkinUnlocked) {
                spawnParticle();
            }

            if (hero.position.y <= CONFIG.cubeSize/2 + CONFIG.heroSize/2) {
                handleLanding();
            }
        }
        
        // ✨ 处理魔方动画
        for(let i = activeRubikAnimations.length - 1; i >= 0; i--) {
            const anim = activeRubikAnimations[i];
            if (anim.currentRotation < anim.targetRotation) {
                const step = anim.speed;
                anim.pivot.rotation.y += step;
                anim.currentRotation += step;
            } else {
                // 动画结束，修正角度，移除动画
                anim.pivot.rotation.y = anim.targetRotation;
                activeRubikAnimations.splice(i, 1);
            }
        }
        
        updateParticles();

        if (state !== 'ended') {
            const targetPos = new THREE.Vector3(
                hero.position.x + 20, 
                20, 
                hero.position.z + 20
            );
            camera.position.lerp(targetPos, 0.03); 
            camera.lookAt(hero.position.x, 0, hero.position.z);
        }

        renderer.render(scene, camera);
    }

    function handleLanding() {
        state = 'ready';
        jumpVelocity = {x:0, y:0, z:0};
        hero.position.y = CONFIG.cubeSize/2 + CONFIG.heroSize/2; 
        hero.rotation.set(0,0,0); 

        const targetBlock = blocks[currentBlockIndex + 1];
        const currentBlock = blocks[currentBlockIndex];
        
        const distToNext = Math.sqrt(
            Math.pow(hero.position.x - targetBlock.x, 2) + 
            Math.pow(hero.position.z - targetBlock.z, 2)
        );
        
        const distToCurr = Math.sqrt(
            Math.pow(hero.position.x - currentBlock.x, 2) + 
            Math.pow(hero.position.z - currentBlock.z, 2)
        );

        if (distToNext < 2.8) {
            successLand(targetBlock, distToNext);
            currentBlockIndex++;
            spawnNextBlock();
        } 
        else if (distToCurr < 2.8) {
            
        }
        else {
            state = 'ended';
            const fallAnim = setInterval(() => {
                hero.position.y -= 0.4; 
                if(hero.position.y < -5) {
                    clearInterval(fallAnim);
                    document.getElementById('final-score').innerText = score;
                    document.getElementById('game-over').style.display = 'block';
                }
            }, 16);
        }
    }

    function successLand(block, distance) {
        let points = 1;
        let text = "+1";
        let color = "#333";

        // ✨ 判定连击：跳到中心（距离 < 0.8）
        if (distance < 0.8) {
            points = 2; 
            text = "完美 +2";
            color = "#ff0000";
            comboCount++; // 累加连击
            playCenterHitSound(comboCount); // 播放“咣”音效
        } else {
            comboCount = 0; // 如果没跳到中心，连击重置
        }

        if (block.type.score > 0) {
            points += block.type.score;
            setTimeout(() => {
                let colorHex;
                if (typeof block.type.color === 'number') {
                     colorHex = '#' + new THREE.Color(block.type.color).getHexString();
                } else {
                     colorHex = "#333"; 
                }
                
                showFloatText(`${block.type.name} +${block.type.score}`, window.innerWidth/2, window.innerHeight/2 - 80, colorHex);
                score += block.type.score;
                updateScoreUI();
                checkSkinUnlock();

                // ⚡️ 2. 触发特殊方块的交互逻辑
                if (block.type.id === 'music') {
                    playMusicBoxMelody();
                } else if (block.type.id === 'rubik') {
                    triggerRubikAnimation(block.mesh);
                } else if (block.type.id === 'store') {
                    lightUpStore(block.mesh);
                }

            }, 500);
        }

        score += points;
        updateScoreUI();
        checkSkinUnlock();
        
        showFloatText(text, window.innerWidth/2, window.innerHeight/2 - 50, color);
    }

    function showFloatText(str, x, y, color) {
        const div = document.createElement('div');
        div.className = 'float-text';
        div.innerText = str;
        div.style.left = x + 'px';
        div.style.top = y + 'px';
        div.style.color = typeof color === 'string' ? color : '#' + color;
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 1500);
    }

    function updateScoreUI() {
        document.getElementById('score').innerText = score;
    }

    function restartGame() {
        startGame();
    }

    init();

</script>
</body>
</html>